const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

const settings = {
  outputFile: "Meta.d.ts",
};

if (process.argv[2]) {
  const parsedSettings = JSON.parse(process.argv[2]);
  Object.assign(settings, parsedSettings);
}

if (!settings.outputFile) {
  console.warn(
    "No output file specified. Please specify an output file in the settings."
  );
  return;
}

// Initial configuration for running script from the project root directory
let packsPath = "./packs/";
let gametestsPath = "./packs/data/gametests/";
// If the script is run as a regolith filter
if (
  process.env.ROOT_DIR &&
  fs.existsSync(process.env.ROOT_DIR + "/config.json")
) {
  let config = JSON.parse(
    fs.readFileSync(process.env.ROOT_DIR + "/config.json", "utf8")
  );
  packsPath = "./";
  gametestsPath = path.normalize(
    process.env.ROOT_DIR + "/" + config.regolith.dataPath + "/gametests/"
  );
}

if (!fs.existsSync(gametestsPath)) {
  console.warn(
    "Could not find gametests directory. Please make sure the gametests directory is present in the dataPath"
  );
  return;
}

// Helper function to load JSON file
function loadJsonFile(filePath) {
  try {
    return JSON.parse(fs.readFileSync(filePath, "utf8"));
  } catch (error) {
    return null;
  }
}

// Helper function to format version array
function formatVersion(versionArray) {
  if (!Array.isArray(versionArray)) return "undefined";
  return `[${versionArray.join(", ")}]`;
}

// Helper function to get git information
function getGitInfo() {
  const gitInfo = {
    commit: null,
    tag: null,
  };

  try {
    // Check if we're in a git repository
    const isGitRepo = execSync("git rev-parse --git-dir", {
      encoding: "utf8",
      stdio: ["pipe", "pipe", "pipe"],
    });

    if (isGitRepo) {
      // Get latest commit hash
      try {
        gitInfo.commit = execSync("git rev-parse HEAD", {
          encoding: "utf8",
        }).trim();
      } catch (e) {
        // No commits yet or git not available
      }

      // Get latest tag
      try {
        gitInfo.tag = execSync("git describe --tags --abbrev=0", {
          encoding: "utf8",
        }).trim();
      } catch (e) {
        // No tags available
      }
    }
  } catch (error) {
    // Not a git repository or git not available
  }

  return gitInfo;
}

// Get manifest data
const manifestData = {
  bp: {
    version: null,
    min_engine_version: null,
  },
  rp: {
    version: null,
    min_engine_version: null,
  },
};

// Load BP manifest
const bpManifestPath = path.join(packsPath, "BP/manifest.json");
if (fs.existsSync(bpManifestPath)) {
  const bpManifest = loadJsonFile(bpManifestPath);
  if (bpManifest && bpManifest.header) {
    manifestData.bp.version = bpManifest.header.version;
    manifestData.bp.min_engine_version = bpManifest.header.min_engine_version;
  }
}

// Load RP manifest
const rpManifestPath = path.join(packsPath, "RP/manifest.json");
if (fs.existsSync(rpManifestPath)) {
  const rpManifest = loadJsonFile(rpManifestPath);
  if (rpManifest && rpManifest.header) {
    manifestData.rp.version = rpManifest.header.version;
    manifestData.rp.min_engine_version = rpManifest.header.min_engine_version;
  }
}

// Get git information
const gitInfo = getGitInfo();

// Generate the .d.ts content
let content = `/**
 * Meta information about the pack
 * Generated by meta_gen filter
 */

declare namespace Meta {
  export namespace manifest {
    export namespace bp {
      export const version: ${formatVersion(manifestData.bp.version)};
      export const min_engine_version: ${formatVersion(manifestData.bp.min_engine_version)};
    }
    export namespace rp {
      export const version: ${formatVersion(manifestData.rp.version)};
      export const min_engine_version: ${formatVersion(manifestData.rp.min_engine_version)};
    }
  }
  export namespace github {
    export const commit: ${gitInfo.commit ? `"${gitInfo.commit}"` : "undefined"};
    export const tag: ${gitInfo.tag ? `"${gitInfo.tag}"` : "undefined"};
  }
}

export default Meta;
`;

// Write to .d.ts file
const outputFilePath = path.join(gametestsPath, "src", settings.outputFile);

let existingContent = "";
if (fs.existsSync(outputFilePath)) {
  existingContent = fs.readFileSync(outputFilePath, "utf8");
}

if (existingContent !== content) {
  // Ensure the directory exists
  const outputDir = path.dirname(outputFilePath);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  fs.writeFileSync(outputFilePath, content, "utf8");
  console.log(
    `Meta file written to ${path.relative(process.env.ROOT_DIR || ".", outputFilePath)}`
  );
}
